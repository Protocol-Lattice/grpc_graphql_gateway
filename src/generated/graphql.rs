// This file is @generated by prost-build.
/// Extend ServiceOptions in order to define grpc connection setting.
/// User can use this option as following:
///
/// service Greeter {
///     option (graphql.service) = {
///       host: "localhost:50051" // define grpc connection host and port
///       insecure: true          // set true if connect to insecure grpc server
///     };
///
///     ... some rpc definitions
/// }
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlService {
    /// gRPC default connection host.
    /// This value should include host and port, say localhost:50051.
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// If true, automatic connection with insecure option.
    #[prost(bool, tag = "2")]
    pub insecure: bool,
}
/// Extend MethodOptions in order to define GraphQL Query or Mutation.
/// User can use this option as following:
///
/// service Greeter {
///     rpc SayHello(HelloRequest) returns (HelloReply) {
///       option (graphql.schema) = {
///         type: QUERY    // declare as Query
///         name: "hello"  // query name
///       }
///     }
/// }
///
/// Since gRPC reason, it has limitation that the response could not be repeated.
/// it's dificcurl to respond array response, so that we accept "response.pluck"
/// in order to expose repeated fields in response message.
///
/// For instance:
///
/// message Member {
///    string name = 1;
/// }
///
/// message ListMembersResponse {
///    repeated Member members = 1; -- could be array response
/// }
///
/// message ListMembersRequest {
/// }
///
/// service MemberService {
///     rpc ListMembers(ListMembersRequest) returns (ListMembersResponse) {
///       option (graphql.schema) = {
///         type: QUERY
///         name: "members"
///         response {
///           repeated : true
///           pluck: "members" // Query will respond \[Member\] instead of ListMembersResponse
///         }
///       }
///     }
/// }
///
/// In mutation declaration:
///
/// service MemberService {
///     rpc CreateMember(CreateMemberRequest) returns (Member) {
///       option (graphql.schema) = {
///         type: MUTATION        // declare as Mutation
///         name: "cretemember"   // mutation name
///       }
///     }
/// }
///
/// The Mutation's input always becomes an input object, so you need to declare argument name.
///
/// message Member {
///    string name = 1;
/// }
///
/// message CreateMemberRequest {
///    string name = 1;
/// }
///
/// service MemberService {
///     rpc CreateMember(CreateMemberRequest) returns (Member) {
///       option (graphql.schema) = {
///         type: MUTATION
///         name: "createmember"
///         request {
///           name: "member" // this is equivalent to createbook(member: Member): Member in GraphQL
///         }
///       }
///     }
/// }
///
/// Finally, user can access this query via /graphql?query={members{name}}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlSchema {
    /// graphql type. Enum of QUERY or MUTATION is valid value
    #[prost(enumeration = "GraphqlType", tag = "1")]
    pub r#type: i32,
    /// query name. this field is required
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Query request object configuration
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<GraphqlRequest>,
    /// Query response object configuration
    #[prost(message, optional, tag = "4")]
    pub response: ::core::option::Option<GraphqlResponse>,
}
/// configuration option for request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlRequest {
    /// Define input name.
    /// This field enables only for mutation and note that if this field is specified,
    /// the gRPC request message will be dealt with an input.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Define pluck message fields
    #[prost(string, repeated, tag = "2")]
    pub plucks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// configuration option for response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlResponse {
    /// If true, this response object is required
    /// But when you declare "pluck", we respect expose field definition.
    #[prost(bool, tag = "1")]
    pub required: bool,
    /// Define pluck message field.
    /// Note that this field IS NOT repeated, just single string field.
    /// It means the response could only be single.
    #[prost(string, tag = "2")]
    pub pluck: ::prost::alloc::string::String,
}
/// GraphqlField is FieldOptions in protobuf in order to define type field attribute.
/// User can use this option as following:
///
/// message Member {
///    string name = 1 \[(graphql.field) = {required: true}\]; // this field is required in GraphQL, it equivalent to String! on GraphQL
/// }
///
/// message CreateMemberRequest {
///    string name = 1; \[(grahpql.field) = {default: "anonymous"}\]; // use default value on input or query
/// }
///
/// Note that in protobuf, all fields are dealt with optional
/// so the same as it, all GraphQL fields are optional as default.
/// If you need to be required, use 'required: true' option
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlField {
    /// If true, this field is required.
    #[prost(bool, tag = "1")]
    pub required: bool,
    /// Use as other field name (not recommend)
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Define default value on input.
    #[prost(string, tag = "3")]
    pub default: ::prost::alloc::string::String,
    /// Omit this field from graphql definition
    #[prost(bool, tag = "4")]
    pub omit: bool,
    /// Resolve this field by nested query with additional RPC
    #[prost(string, tag = "5")]
    pub resolver: ::prost::alloc::string::String,
    /// Federation: Mark this field as external (part of another service's entity)
    #[prost(bool, tag = "6")]
    pub external: bool,
    /// Federation: Specify fields this field requires from other services
    #[prost(string, tag = "7")]
    pub requires: ::prost::alloc::string::String,
    /// Federation: Specify fields this field provides to the supergraph
    #[prost(string, tag = "8")]
    pub provides: ::prost::alloc::string::String,
    /// Federation: Mark this field as shareable (can be resolved from multiple subgraphs)
    #[prost(bool, tag = "9")]
    pub shareable: bool,
}
/// Federation configuration for message types (entities).
/// User can use this option to define federated entities:
///
/// message User {
///    option (graphql.entity) = {
///      keys: "id"
///      keys: "email"
///    };
///    string id = 1;
///    string email = 2;
///    string name = 3;
/// }
///
/// For extending entities from another service:
///
/// message Product {
///    option (graphql.entity) = {
///      extend: true
///      keys: "upc"
///    };
///    string upc = 1 \[(graphql.field) = {external: true}\];
///    int32 stock = 2;
/// }
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlEntity {
    /// List of key fields or field sets that uniquely identify this entity
    /// Each key can be a single field name or a field set like "id email"
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, this message extends an entity defined in another service
    #[prost(bool, tag = "2")]
    pub extend: bool,
    /// If specified, this service will be resolvable (implements _entities resolver)
    #[prost(bool, tag = "3")]
    pub resolvable: bool,
}
/// Live Query configuration for reactive subscriptions.
/// User can use this option to enable live queries on specific RPC methods:
///
/// service UserService {
///     rpc GetUser(GetUserRequest) returns (User) {
///       option (graphql.schema) = {
///         type: QUERY
///         name: "user"
///       };
///       option (graphql.live_query) = {
///         enabled: true
///         throttle_ms: 100
///         triggers: \["User.update", "User.delete"\]
///       };
///     }
/// }
///
/// When a client sends a query with @live directive:
///    query @live { user(id: "1") { name status } }
///
/// The gateway will:
/// 1. Execute the query immediately
/// 2. Re-execute and push updates when any trigger fires
/// 3. Throttle updates to prevent flooding (default: 100ms)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphqlLiveQuery {
    /// Enable live query support for this method
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Minimum time between updates in milliseconds (default: 100ms)
    /// Prevents flooding clients with too many updates
    #[prost(uint32, tag = "2")]
    pub throttle_ms: u32,
    /// List of invalidation triggers that cause re-execution
    /// Format: "TypeName.action" where action is: create, update, delete, or *
    /// Examples: "User.update", "Post.*", "Comment.create"
    #[prost(string, repeated, tag = "3")]
    pub triggers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Maximum number of concurrent live query connections per client (default: 10)
    #[prost(uint32, tag = "4")]
    pub max_connections: u32,
    /// Time-to-live in seconds. Live query auto-closes after this duration (0 = infinite)
    #[prost(uint32, tag = "5")]
    pub ttl_seconds: u32,
    /// Strategy for detecting changes
    #[prost(enumeration = "LiveQueryStrategy", tag = "6")]
    pub strategy: i32,
    /// For POLLING strategy: interval in milliseconds
    #[prost(uint32, tag = "7")]
    pub poll_interval_ms: u32,
    /// Entities this query depends on (for automatic invalidation)
    #[prost(string, repeated, tag = "8")]
    pub depends_on: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// explicit schema declaration enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GraphqlType {
    /// schema will generate as Query
    Query = 0,
    /// schema will generate as Mutation
    Mutation = 1,
    /// schema will generate as Resolver. Resolver behaves not listed in query, but can resolve nested field.
    Resolver = 2,
    /// schema will generate Subscription.
    Subscription = 3,
}
impl GraphqlType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Query => "QUERY",
            Self::Mutation => "MUTATION",
            Self::Resolver => "RESOLVER",
            Self::Subscription => "SUBSCRIPTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY" => Some(Self::Query),
            "MUTATION" => Some(Self::Mutation),
            "RESOLVER" => Some(Self::Resolver),
            "SUBSCRIPTION" => Some(Self::Subscription),
            _ => None,
        }
    }
}
/// Strategy for detecting when to push live query updates
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LiveQueryStrategy {
    /// Push updates when invalidation triggers fire (recommended)
    Invalidation = 0,
    /// Poll the underlying data source at regular intervals
    Polling = 1,
    /// Compare response hashes to detect changes
    HashDiff = 2,
}
impl LiveQueryStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalidation => "INVALIDATION",
            Self::Polling => "POLLING",
            Self::HashDiff => "HASH_DIFF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVALIDATION" => Some(Self::Invalidation),
            "POLLING" => Some(Self::Polling),
            "HASH_DIFF" => Some(Self::HashDiff),
            _ => None,
        }
    }
}
